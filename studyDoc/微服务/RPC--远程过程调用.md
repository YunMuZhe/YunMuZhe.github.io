# RPC--远程过程调用

## 概述
RPC即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议，看完下文我会再次出现进行解释。

## 组件介绍
RPC主要分为如下四个组件：
- Registry -- 服务注册中心
- Provider -- 服务提供者
- Consumer -- 服务消费者，也是对外开放的访问窗口
- Monitor -- 监控者，获取各个角色的消息

下面进行详解

1. Registry
	1. 作为注册中心，接收Provider和Consumer的注册信息
	2. 作为订阅信息提供者，接收Consumer的订阅请求，并返回对应的订阅信息
	3. 当注册信息变化时，主动通知订阅者
2. Provider
	1. 作为客户端，在Registry上注册表明自己的存在，随时向Monitor发送统计信息
	2. 作为服务端，提供服务（API）供Consumer调用
3. Consumer
	1. 向Registry发送请求，获取需要调用的API所在Provider的网络地址
	2. 向Provider发送调用API请求
4. Monitor
	1. 与各个角色建立TCP长连接，接收各角色发送过来的统计信息并进行处理
	2. 可使用消息队列，增强健壮性 

## 过程概览
1. Registry启动，等待各个Provider、Consumer的注册
2. Provider启动后，向Registry发送注册信息，在Registry上完成注册
3. Consumer获取要调用API的请求，去找Registry订阅API所在Provider的网络地址
4. Registry获取订阅请求，返回API所在Provider的网络地址
5. Consumer访问那个网络地址调用API
6. Provider获取API请求，完成调用后返回结果给Consumer
7. Consumer完成调用

- 以上任何角色、任何步骤所产生的信息均会发送给Monitor，Monitor进行记录、处理

直接放图：

![SpringCloud微服务架构图解.png](https://upload-images.jianshu.io/upload_images/6324621-96990210ae890544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 远程过程调用与本地调用的区别

### 相对于本地调用，远程过程调用的难点
本地调用过程：在内存中、对值进行压栈出栈操作、对函数进行压栈出栈操作，调用函数时编译器直接调用函数指针，但在RPC中则不行，因为两个进程的地址空间是不同的，所以由此引发了三个难点：

> 如何准确的调用到需要的函数
> 
> 如果不使用栈的话，调用参数如何传递
> 
> 如何将参数传递到远程

### 难点的解决
1. 如何准确调用函数 -- **Call ID映射**

> 本地和远程均具有一张  **函数：ID**  对应表，两张表中函数名称可以不同，但是ID必须相对应（对函数逻辑相同的函数来说），比如一个获取UserName的函数，本地表中函数名称为GetUserName1，而远程表中函数名称为GetUserName2，但是本地表中内容为GetUserName1:0001，远程表中内容为：GetUserName2:0001，那么本地调用GetUserName1就能调用到远程的GetUserName2

2. 如果不使用栈的话，调用参数如何传递 -- **序列化和反序列化**

> 语言都不一定相同的两台主机，该如何传递参数呢？答案是序列化与反序列化，在本地将参数序列化变为都能读取的字节流，在远程将字节流变为自己能够处理的结构化数据进行处理。

3. 如何将参数传递到远程 -- **网络传输**

> 远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。