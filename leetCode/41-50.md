# 1. 缺失的第一个正数
原题：https://leetcode-cn.com/problems/first-missing-positive/

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:
> 
> 输入: [1,2,0]
> 
> 输出: 3

示例 2:
> 
> 输入: [3,4,-1,1]
> 
> 输出: 2

示例 3:
> 
> 输入: [7,8,9,11,12]
> 
> 输出: 1

> 说明:
> 
> **你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。**


##### 思路分析

此题如果只看开头没有看说明会觉得非常简单，但是难就难在那个对时间复杂度以及空间复杂度的要求上

在LeetCode上看到一个非常棒的思路，分享出来：

遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，

然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，

否则遍历完都没出现那么答案就是数组长度加1。

> 但是这种解法并不满足题目要求，因为有```int[] tmp = new int[n+2];```存在，占用的空间并不是O(1)，所以需要另想办法。

        public int firstMissingPositive(int[] nums) {
            int n = nums.length;
            if(n == 0 || nums == null) {
                return 1;
            }
            int[] tmp = new int[n+2];
            for(int i=0;i<n;i++) {
                if(nums[i] > 0 && nums[i] <= n) {
                    tmp[nums[i]] = nums[i];
                }
            }
            for(int i=1;i<=n+1;i++) {
                if(tmp[i] != i) {
                    return i;
                }
            }
            return n;
        }

上面这种方法非常巧妙，利用到了数组的索引，如果不想超时的话关键在于让数组变为有序的，那能不能不新建数组直接在原来的空间上进行排序呢？


