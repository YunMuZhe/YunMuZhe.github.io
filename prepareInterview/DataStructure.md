## 一、 链表：

题目：

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第k个节点
- 寻找链表的中间节点

## 二、 队列和栈

循环队列判空条件：head == tail，判满条件：(tail+1)%n == head
无论是用队列实现栈还是用栈实现队列，都是要用两个数据结构来实现另一个数据结构，很像Eden区的From和To区之间的转换，将n-1个数据由一个数据结构迁移到另一个数据机构，然后更换角色

## 三、 排序算法(最好时间复杂度、最差时间复杂度、平均时间复杂度、空间复杂度)：

### 1. O(n^2)的排序算法有：

- 冒泡排序：n\n^2\n^2\1，原地、稳定
- 插入排序：n\n^2\n^2\1，原地、稳定
- 选择排序：n^2\n^2\n^2\1，原地、不稳定

### 2. O(nlogn)排序：

- 归并排序：nlogn\nlogn\nlogn\logn，非原地、稳定，主要在于合并函数merge()
- 快速排序：nlogn\n^2\nlogn\n，原地、不稳定

### 3. 场景题：如何在O(n)的诗句复杂度内查找一个无序数组中的第K大元素？

答：利用快速排序的分区方法，选择数组A[0, n-1]中最后一个元素作为pivot，对数组A进行原地分区，这样就分成了三部分：A[0, p-1], A[p], A[p+1, n-1]
如果K = p+1，那么A[p]就是第K大元素，否则对两边的分区进一步分区。
时间复杂度分析：第一次分区需要遍历n个元素，第二次为n/2, 第三次为n/4，以此类推，直到变成1，总遍历元素个数为n + n/2 + n/4 + n/8 + ... + 1 = 2n-1

### 4. O(n)排序：

- 桶排序：时间复杂度为O(n)，但是对数据要求严格，1.待排序数据容易划分为m个桶，并且桶与桶之间有着天然的大小关系。此算法适合用于外部排序。非原地，稳定

- 计数排序：时间复杂度为O(n)，是桶排序的一种特殊情况，第i个桶内装的原数组中小于等于i的元素的个数。非原地，稳定

- 基数排序：时间复杂度为O(n)，需要数据可以分割出独立的位，并且位与位之间要有递进关系:后面的排序能用到前面排序的结果。非原地，稳定

### 5. 题目-二分查找变体问题（P86）：

1. 查找第一个值等于给定值的元素
2. 找最后一个值等于给定值的元素
3. 查找第一个值大于或等于给定值的元素
4. 找最后一个值小于或等于给定值的元素
5. 如何快速定位IP地址对应的归属地

## 四、 哈希：

**哈希思想：key-value，数组其实就是一种哈希表，key为index，value为具体元素**

哈希函数：hash(key)，结果需要为非负值，如果key1 == key2 => hash(key1) == hash(key2); 如果key1 != key2 => hash(key1) != hash(key2)。最后一个要求，找到不会发生哈希膨胀的哈希函数是几乎不可能的

### 哈希冲突：

- 开放寻址法：线性探测法、二次探测法、双重哈希法
- 链表法：此处有个装载因子的概念：哈希表中元素个数/哈希表的长度（“槽”的个数），其实就是所有链表的平均长度

### 如何打造一个工业级的哈希表

需要满足的条件：

1. 快速的查询、插入、删除操作
2. 内存占用合理，不浪费过多的内存空间
3. 性能稳定，在极端情况下性能也不会退化到无法接受的程度
4. 设计要点：
   - 设计哈希函数：像数据分析法、直接寻址法、平方取中法、折叠法和随机数法
   - 解决装载因子过大的问题：动态扩容
   - 避免低效的扩容：将扩容时的复制操作均摊到后续的插入操作中
   - 选择合适的冲突解决方法：
      开放寻址法适合用于数据量比较小，装载因子较小的情况，ThreadLocalMap使用的即是此种方法
      链表法的内存利用率比开放寻址法更高（链表可以用到时再创建），极端的哈希冲突可以使用更高级的数据结构来避免退化严重，如红黑树。

**题目-哈希表优化场景问题（P101）：使用哈希表优化LUR缓存淘汰算法**

### linkedHashMap：双向有序链表+哈希表

### 位图：

1. 概念：每个二进制位用0/1来代表true/false，多个二进制位组成位图，第n个二进制位为true则代表n存在。
2. 题目-手动使用char[]实现一个位图(P108)
3. 布隆过滤器：将数据用哈希算法进行处理，依然落在最终我们设置的一个范围中。可以使用多个哈希函数一起定位一个数据来减少发啥哈希冲突的概率。
   通过布隆过滤器判断不存在的数据一定不存在，但是判断存在的数据不一定存在，因为是通过多个哈希函数来定位的最终的坐标的，所有坐标上的数据都为true才代表数据存在，但是如果存储的数据很多，很可能会出现1,2、2,3导致1,3也存在的现象，可能会误判。

### 哈希算法(将任意长度的二进制值串映射为固定长度的二进制值串)

#### 用处：

1. 安全加密：对明文密码加密后存到数据库中
2. 唯一标识：查询一张图片是否存在
3. 数据校验：将分割的多个文件数据块下载下来之后查看合并后的文件的哈希值是否与目标值相同。
4. 哈希函数
5. 负载均衡：将客户端的IP地址计算得到哈希值后，与服务器个数求模取余
6. 数据分片：将大数据分块，不同的块计算哈希值后交给不同的机器进行处理——MapReduce
7. 分布式存储：此处有个扩容问题，可以在一开始就多设计一些容量，然后每个机器多处理几个映射之后的值的数据，扩容后只需将几个机器上的数据迁移出去即可，不会出现大面积缓存失效导致缓存击穿的问题。（缓存穿透指的是多次请求缓存和数据库都没有的数据）
