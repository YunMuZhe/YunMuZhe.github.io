# IO流

## Java中的IO流体系

Java中的IO流可按照操作单元来分类，分成字节流和字符流，分别操作的数据单元为8位的字节和16位的字符。

字节流主要是由InputStream和OutPutStream作为基类，而字符流主要是由Reader和Writer作为基类。

## 五种IO模型

> 参考链接：https://zhuanlan.zhihu.com/p/115912936

1. 阻塞IO模型

   请求数据时，若没有数据准备好，应用会一直阻塞，直到内核准备好数据并返回给应用，才会结束此次数据请求的调用。

2. 非阻塞IO模型

   请求数据时，若没有数据准备好，会直接返回，通知应用此时没有数据，不会让应用一直在此等待。因此，应用如果想每次都迅速的相应数据，需要一直不断地调用数据请求的方法。

3. IO复用模型

   一个线程监控多个网络请求（fd文件描述符），这样就可以用一个或几个线程完成大量网络请求数据的监控，当有数据进来的时候，再去分配对应的线程去读取数据。

   进程通过将一个或多个fd传递给select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。

   **此模型可达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。**

4. 信号驱动IO模型

   首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数。

   此时进程通过将一个或多个fd传递给select，调用方法即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，select通过信号回调对应的回调方法，应用程序再调用recvfrom读取数据。

   **实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。**

5. 异步IO模型

   应用告知内核启动某个操作，并让内核在整个操作完成之后通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们何时可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。

   **异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。**

### 同步、异步模型的区别

同步的意思是，从请求发起到数据最后完成的这一段都是同一个线程亲力亲为。

而异步则相反，发送完指令就不再参与了，只需要等待最终完成的结果的通知。

### 阻塞、非阻塞的区别

阻塞的意思是，请求的时候，如果数据没有就绪就一直在这里等待数据的就绪。

非阻塞的意思则为，如果请求时没有数据就绪则直接返回。

### 同步阻塞、同步非阻塞、异步非阻塞

对于同步阻塞、同步非阻塞来说，区别仅仅在于请求时若数据没有就绪是否继续等待，他们都需要自己监控数据完成的过程。至于为何没有异步阻塞模型，原因则在于请求后就直接返回了，去等待通知了，所以注定不会被阻塞掉。

