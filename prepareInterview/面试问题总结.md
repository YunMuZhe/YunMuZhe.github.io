# Java
## java中快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
1. 快速失败（fail—fast）

	在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。

	**原理**：迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “mode” ，当集合结构改变（添加删除或者修改），标记"mode"会被修改，而迭代器每次的hasNext()和next()方法都会检查该"mode"是否被改变，当检测到被修改时，抛出Concurrent Modification Exception

	**场景**：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

2. 安全失败（fail—safe）

	采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
	
	**原理**：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
	
	**缺点**：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

	**场景**：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
3. 区别：一个直接访问源数据，有人修改及抛异常，一个先拷贝一份再访问，但是不能及时获取到最新的数据。

## 类加载机制

### 1.类加载过程
类加载分为三个过程：加载、连接、初始化，而连接又分为三部分：验证、准备、解析。
#### 加载
加载即为将类的class文件读入内存，并为之创建一个 java.lang.Class 对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。

	- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
	- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
	- 通过网络加载class文件。
	- 把一个Java源文件动态编译，并执行加载。

类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。

#### 连接
1. 验证

	验证被加载的类是否有正确的内部结构，包括文件格式验证、元数据验证、字节码验证、符号引用验证
		1. 文件格式验证： 验证字节流是否符合CLASS文件格式规范
		2. 元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范
		2. 字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。
		3. 符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。
2. 准备

	负责为类的静态变量分配内存，并设置默认初始值。
3. 解析

	将类的二进制数据中的符号引用替换成直接引用。
#### 初始化

	为类的静态变量赋正确的值
### 2.类加载时机
1. 创建类的实例
2. 访问某个类的静态变量或者对该静态变量进行赋值
3. 调用某个类的静态方法
4. 反射（Class.forName("com.hfut.edu.Main")）
5. 初始化一个类的子类（会首先初始化其父类）
6. 执行main函数会导致其所在的类初始化
### 3.类加载器(待补充)
### 4.类加载机制

#### 全盘负责

当一个类加载器加载一个类时，和其有关的类的加载的任务这个类加载器都要负责，和其有关的类即为该class的依赖和该class引用的类
#### 双亲委派

一个类加载器加载一个类时不是直接就加载，而是先看看有没有父类加载器，有的话先让父类加载器看看其缓冲区内有没有，有的话就拿来用不会再加载了。而这个任务传给父类加载器之后父类加载器也和它的子类加载器一样，一代一代向上传，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。

即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。

**优势：**
1. 避免类的重复加载：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。
2. 安全：保证java核心api库不会被随意篡改。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

#### 缓存机制

缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

## HashMap、Hashtable、ConcurrentHashMap的原理与区别
1. HashTable
	+ 底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时都锁住了整个HashTable，效率低，ConcurrentHashMap做了相关优化
	+ 初始size为11，扩容：newsize = olesize*2+1
	+ 计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length
2. HashMap
	+ 底层数组+链表实现，可以存储null键和null值，线程不安全
	+ 初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂
	+ 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
	+ 插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）
	+ HashMap能够将键设为null(只能用有一个)，也可以将值设为null，所以使用contain(key)之后如果返回null，有两种可能：
		+ HashMap中没有这个key
		+ 这个key对应的value是null
	+ 当Map中元素总数超过Entry数组的75%(**这个数为加载因子，默认为75%，可修改，此值的设置用到了泊松分布，经过大量的计算研究之后发现，大于75%之后哈希碰撞的概率几乎可以不计，所以使用了75%**)，触发扩容操作，为了减少链表长度，元素分配更均匀
	+ 计算index方法：index = hash & (tab.length – 1)
	+ 初始的entry数组的长度一定为2的幂次方，只有这样，算hashcode--hash & (tab.length – 1)的时候才能大大减小hash碰撞的概率
		+ 原因：假设不是2的幂次方，而是10，则计算hashcode时是计算的传进来的数与10及0000 1001相与，中间的两个0与任何数相与都是0，这样就会大大增加hash碰撞的概率
	+ 一般而言，HashMap的key是要用类似String、Integer这样的不可变类的。为什么呢？
		> String这种不可变类有一个private变量--hash
		> 
		> 所以，使用String当做key，会在第一次调用hashCode方法时，计算出hash值，以后的调用直接使用已缓存的hash值。这样设计，又能大大的提升HashMap的性能。
		> 
		> 所以，推荐使用这种不可变类。
		> 
		> 如果你想用自定义的类当做key，那么，请参考String类的设计，而且，这个你自定义的类必须是不可变得，至少参与hashCode计算的字段是不可变的，不然，会出现存进去的键值对和取出来的键值对不一致。 
3. ConcurrentHashMap
	- 底层采用分段的数组+链表实现，线程安全
	- 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)
	- Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
	- 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
	- 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容
	- ConcurrentHashMap是使用了锁分段技术来保证线程安全的。
	- 锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 
4. 区别：一开始用的是HashTable和HashMap，HashTable是为了线程安全，但是效率实在太低，于是增加了一个 ConcurrentHashMap，也是线程安全，但是实现方式不一样了，分成了n个段，访问一个段的时候也能访问其他段，提升了效率

## 解决Hash冲突的四个方法
约定： H(key)为一开始的哈希函数算出来的哈希地址
### 1. 开放定址法（再散列法）
当关键字的哈希地址 p = H(key) 出现冲突时，以 p 为基础，产生另一个哈希地址p1，如果p1依然存在冲突，则再以p为基础，生成另一个哈希地址p2，一直到不产生冲突为止。

一个通用的 再散列函数 如下 ：

 ` Hi=（H（key）+di）% m   i=1，2，…，n`

主要有如下三种方法：
1. 线性探测再散列

	出现冲突后，直接闷着头往后继续找，找到空位就直接插进去。

2. 二次探测再散列

	di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )
	
	特点是冲突发生后就左右跳跃，找到空位就直接插进去。

3. 伪随机探测再散列

	di是一个伪随机数数列
### 2. 再哈希法
准备多个哈希函数备用，一个不管用就用备用的
### 3. 链地址法
哈希地址相同的元素其实保存在一个链表中，有冲突就直接往对应的链表后面插即可
### 4. 建立公共溢出区
将hash表分为基本表和溢出表两部分，和基本表发生冲突的元素，一律填入溢出表

### 5. 优缺点
1. 拉链法（开放散列）
	- 优点：
		- 元素总数不确定时处理的较好
		- 删除较为方便
	- 缺点
		- 存储地址随机分布，相较于固定分布的数组来说，效率会差一些
		- 总数不变时可以设计一个不会产生冲突的完美哈希函数，此时封闭散列的性能将远高于开放散列
		- 不容易进行序列化操作
2. 开发定址法（封闭散列）
	- 优点
		- 容易序列化
		- 总数不变可以开发完美哈希函数，效率高
	- 缺点
		- 总数变化时可能会导致经常性扩容，扩容开销很大，会严重影响性能
		- 删除时比较麻烦，需要将后续插入的元素都往前移，不然会产生找不到元素的情况发生

# 操作系统


# 网络


# Linux


#数据库


# 算法

## 常见排序算法
![排序算法](https://img-blog.csdn.net/20171027131711311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 有N个节点的满二叉树的高度
1+logN

## 如何实现关键字输入提示


> 使用字典树

复杂度多少？有没有其他方案？

> 哈希

如果是中文呢

> 分词后建立字典树？

## 红黑树

红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

1. 红色节点向左倾斜
2. 一个节点不可能有两个红色链接
3. 整个书完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

# 幂等性如何保障

# 分布式事务

# 分布式锁

# 零拷贝技术

# NIO原理

# 线程模型Reactor

# DDD领域驱动设计以及平时开发的规范
