# Java

## java中快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
1. 快速失败（fail—fast）

	在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。

	**原理**：迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “mode” ，当集合结构改变（添加删除或者修改），标记"mode"会被修改，而迭代器每次的hasNext()和next()方法都会检查该"mode"是否被改变，当检测到被修改时，抛出Concurrent Modification Exception

	**场景**：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

2. 安全失败（fail—safe）

	采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
	
	**原理**：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
	
	**缺点**：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

	**场景**：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
3. 区别：一个直接访问源数据，有人修改及抛异常，一个先拷贝一份再访问，但是不能及时获取到最新的数据。

## 类加载机制

### 1.类加载过程
类加载分为三个过程：加载、连接、初始化，而连接又分为三部分：验证、准备、解析。
#### 加载
加载即为将类的class文件读入内存，并为之创建一个 java.lang.Class 对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。

	- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
	- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
	- 通过网络加载class文件。
	- 把一个Java源文件动态编译，并执行加载。

类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。

#### 连接
- 验证


验证被加载的类是否有正确的内部结构，包括文件格式验证、元数据验证、字节码验证、符号引用验证
   	1. 文件格式验证： 验证字节流是否符合CLASS文件格式规范
 	2. 元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范
 	3. 字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。
 	4. 符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。

- 准备


负责为类的静态变量分配内存，并设置默认初始值。

- 解析

将类的二进制数据中的符号引用替换成直接引用。

#### 初始化

为类的静态变量赋正确的值

### 2.类加载时机
1. 创建类的实例
2. 访问某个类的静态变量或者对该静态变量进行赋值
3. 调用某个类的静态方法
4. 反射（Class.forName("com.hfut.edu.Main")）
5. 初始化一个类的子类（会首先初始化其父类）
6. 执行main函数会导致其所在的类初始化
### 3.类加载器(待补充)
## 解决Hash冲突的四个方法
约定： H(key)为一开始的哈希函数算出来的哈希地址
### 1. 开放定址法（再散列法）
当关键字的哈希地址 p = H(key) 出现冲突时，以 p 为基础，产生另一个哈希地址p1，如果p1依然存在冲突，则再以p为基础，生成另一个哈希地址p2，一直到不产生冲突为止。

一个通用的 再散列函数 如下 ：

 ` Hi=（H（key）+di）% m   i=1，2，…，n`

主要有如下三种方法：
1. 线性探测再散列

	出现冲突后，直接闷着头往后继续找，找到空位就直接插进去。

2. 二次探测再散列

	di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )
	
	特点是冲突发生后就左右跳跃，找到空位就直接插进去。

3. 伪随机探测再散列

	di是一个伪随机数数列
### 2. 再哈希法
准备多个哈希函数备用，一个不管用就用备用的
### 3. 链地址法
哈希地址相同的元素其实保存在一个链表中，有冲突就直接往对应的链表后面插即可
### 4. 建立公共溢出区
将hash表分为基本表和溢出表两部分，和基本表发生冲突的元素，一律填入溢出表

### 5. 优缺点
1. 拉链法（开放散列）
	- 优点：
		- 元素总数不确定时处理的较好
		- 删除较为方便
	- 缺点
		- 存储地址随机分布，相较于固定分布的数组来说，效率会差一些
		- 总数不变时可以设计一个不会产生冲突的完美哈希函数，此时封闭散列的性能将远高于开放散列
		- 不容易进行序列化操作
2. 开发定址法（封闭散列）
	- 优点
		- 容易序列化
		- 总数不变可以开发完美哈希函数，效率高
	- 缺点
		- 总数变化时可能会导致经常性扩容，扩容开销很大，会严重影响性能
		- 删除时比较麻烦，需要将后续插入的元素都往前移，不然会产生找不到元素的情况发生

# 操作系统


# Linux


# 算法

## 常见排序算法
![排序算法](https://img-blog.csdn.net/20171027131711311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 有N个节点的满二叉树的高度
1+logN

## 如何实现关键字输入提示


> 使用字典树

复杂度多少？有没有其他方案？

> 哈希

如果是中文呢

> 分词后建立字典树？

## 红黑树

红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

1. 节点只能为红色或者黑色
2. 根节点一定是黑色的
3. 叶子节点一定是黑色的
4. 红色节点必须有两个黑色子节点
5. 任一节点到其每个叶子节点的路径中，包含相同数量的黑色节点

# 内存映射技术——MMap

实现的目标：把一个磁盘文件映射到内存里来，然后把映射到内存里来的数据通过socket发送出去

有一种mmap技术，也就是内存映射，直接将磁盘文件数据映射到内核缓冲区，这个映射的过程是基于DMA引擎拷贝的，同时用户缓冲区是跟内核缓冲区共享一块映射数据的，建立共享映射之后，就不需要从内核缓冲区拷贝到用户缓冲区了。

光是这一点，就可以避免一次拷贝了，但是这个过程中还是会用户态切换到内核态去进行映射拷贝，接着再次从内核态切换到用户态，建立用户缓冲区和内核缓冲区的映射。

接着把数据通过Socket发送出去，还是要再次切换到内核态。

接着直接把内核缓冲区里的数据拷贝到Socket缓冲区里去，然后再拷贝到网络协议引擎里，发送出去就可以了，最后切换回用户态。

减少一次拷贝，但是并不减少切换次数，一共是4次切换，3次拷贝。

mmap技术是主要在RocketMQ里来使用的。

# 零拷贝技术

1. 从用户态切换到内核态，在内核态的状态下，把磁盘上的数据拷贝到内核缓冲区，同时从内核缓冲区拷贝一些offset和length到Socket缓冲区
2. 从内核态切换到用户态，从内核缓冲区直接把数据拷贝到网络协议引擎里去

零拷贝技术只要**2次切换，2次拷贝**，就可以了

kafka、tomcat，都是用的零拷贝技术，rocketmq用的是mmap技术，mmap还是要多2次切换和1次拷贝的。

# 如何将一个长地址映射为短地址呢？

## 生成流程（使用放号器）

（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。

（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：t.cn/sBc。

（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -> URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。

## 跳转过程

（1）用户访问短链接：http://t.cn/RuPKzRW；

（2）短链接服务器t.cn收到请求，根据URL路径RuPKzRW获取到原始的长链接（KV缓存数据库中去查找）：https://blog.csdn.net/xlgen157387/article/details/79863301；

（3）服务器返回302状态码，将响应头中的Location设置为：https://blog.csdn.net/xlgen157387/article/details/79863301；

（4）浏览器重新向https://blog.csdn.net/xlgen157387/article/details/79863301发送请求；

（5）返回响应；

## 优化的点

1. 算法优化：为了避免一个长地址生成了多个短地址，造成资源浪费，可以使用查表的方式（DB效率较低）或者本地LUR缓存（存储最近N次的映射结果）去进行查重。

2. 可伸缩和高可用

   使用“分片”思想将放号器集群化：每个实例负责特定号段的分发，比如部署10台Redis，每台分别负责号段尾号0-9的分发，此时发号器的步长设置为10（实例数量）。

   另外，也可将长链接与短链接映射关系的存储进行分片，由于没有一个中心化的存储位置，因此需要开发额外的服务，用于查找短链接对应的原始链接的存储节点，这样才能去正确的节点上找到映射关系。

# 线程模型Reactor

# DDD领域驱动设计以及平时开发的规范

