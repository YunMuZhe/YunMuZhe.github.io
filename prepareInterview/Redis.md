# Redis

## Redis的基础使用

### String

```shell
get key value # 获取键值
set key value # 设置键值
del key # 删除键
```

### List

```shell
RPUSH key element [...element] # 将给定值推入列表的右端
LPUSH key element [...element] # 将给定值推入列表的左端
LRANGE key start end # 获取列表从start下标到end下标的所有数据
LPOP/RPOP # 从列表的左端/右端弹出一个值
LINDEX key index # 获取列表位于index位置的值
```

### Set

```shell
SADD key element [...element] # 将给定值加入到集合中
SREM key  element [...element] # 将给定值从集合中删除
SISMEMBER key  element [...element] # 判断给定值是否在集合中
SMEMBERS key # 获取集合中所有元素，会引起阻塞，生产环境慎用
SINTER/SUNION/SDIFF key1 key2 # 对集合1和集合2取交集、并集、差集
```

### Hash

```shell
HSET key field value # 将给定value插入到key的hash表中，以field为key
HGET key field # 获得key的hash表中field的value
HGETALL key # 获取key的hash表中的所有field、value键值对
HDEL key field # 在key的hash表中删除指定的field
```

### ZSet

```shell
ZADD key score member [... score member] # 将给定的member和score加入到zset中
ZRANGE key start end # 从zset中获取排序后的index在start到end的所有值
ZRANGEBYSCORE key startScore endScore # 从zset中获取score在startScore到endScore的所有值
ZREM key member # 如果zset中有这个值，则移除0
ZINCRBY key score mebmer # 为zset中member的score新增一个值
```



## Redis单线程为什么这么快

Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快

1. 使用简单的数据结构
2. 基于内存
3. 使用非阻塞IO多路复用模型
   1. redis基于Reactor模式开发了网络事件处理器（单线程）、文件事件处理器file event handler。他是单线程的，所以redis才叫做单线程的模型，它采用io多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。
   2. 需要了解Epoll的实现机制。
   3. 文件事件处理器的结构包括4个部分：多个Socket、IO多路服用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。
   4. 多个Socket可能并发产生不用的事件，IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中有序、同步取出一个Socket给事件分派器，事件分派器会把Socket分给对应的事件处理器。
   5. 当Socket的事件处理完成之后，IO多路复用程序才会将队列中的下一个Socket给事件分配器，文件事件分派器会根据每个Socket当前产生的事件来选择对应的事件处理器来处理。
4. 自己实现了VM
5. 单线程，避免了不必要的上下文切换和竞争条件

## Redis有哪些数据结构，分别有哪些典型的应用场景？

1. 字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就是利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID。
2. 哈希表：可以用来存储一些key-value键值对，更适合用来存储对象
3. 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等的消息流数据。
4. 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似于我和某人共同关注的人、朋友圈点赞等功能。
5. 有序集合：集合是无序的，有序集合可以用来设置顺序，可以用来实现排行榜功能。
6. Bitmap：布隆过滤器
7. GeoHash：坐标，借助SortedSet实现，通过zset的score进行排序就可以得到坐标附近的其他元素，通过将score还原成坐标值就可以得到元素的原始坐标。
8. HyperLogLog：统计不重复数据，用于大数据基数统计，效率较高
9. Streams：内存版的kafka，进行消息的订阅、发布，pub/sub

## Redis的持久化机制

### RDB（Redis Database）：

将某一时刻的内存快照，以二进制的方式写入磁盘。

#### 手动触发

- ​	save命令，使Redis处于阻塞状态，直到RDB持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。
- ​	bgsave命令，fork出一个子进程进行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了。使用了操作系统的cow（copy on write）写时拷贝机制，主进程会操作一个原数据的数据副本。

#### 自动触发

- ​	save m n：在m秒内，如果有n个键发生改变，则自动触发持久化，通过bgsave执行，**如果设置多个，只要满足其一就会触发**，配置文件有默认配置（可以注释掉）。
- ​	flushall：用于清空redis所有的数据库；而flushdb命令清空当前redis所在库数据（默认是0号数据库），这两个命令都会清空RDB文件，同时也会生成dump.rdb，内容为空。
- ​	主从同步：全量同步时会自动触发bgsave命令，生成rbd发送给从节点。
- 当服务器收到shutdown命令或者收到term信号时，会执行save命令，阻塞所有客户端，不再执行客户端的任何命令，并在save命令执行完毕之后关闭服务器。

#### 优点

1. 整个redis数据库中质保函一个文件dump.rdb，方便持久化
2. 容灾性好，方便备份
3. 性能最大化，fork子进程来完成写操作，让主进程继续执行命令，所以是io最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis 的高性能。
4. 相对于数据集大时，比AOF的启动效率更高。

#### 缺点

1. 数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失的风险，所以这种方式更适合数据要求不严谨的时候
2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集比较大时，可能会导致整个服务器停止服务几百毫秒，甚至到1s。并且fork出来的子进程会占用CPU。

#### 修复工具

redis-check-dump

### AOP（Append Only File）：

以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘

1. 所有的写命令都会追加到AOF缓冲中
2. AOF缓冲区根据对应的策略向磁盘进行同步操作
3. 随着AOF文件越来越大，需要定期对AOF文件进行重写（rewrite），达到压缩的目的，例如通过三条命令往list中分别写入1、2、3，可以写为一条命令往list中写入1、2、3
4. 当Redis重启时，可以加载AOF文件进行数据恢复

#### 同步策略

- 每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失
- 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条
- 不同步：由操作系统控制，可能丢失较多数据

#### 优点

1. 数据安全；
2. 通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题；
3. AOF机制的rewrite模式，定期对AOF文件进行重写，以达到压缩的目的。

#### 缺点

1. AOF文件比RDB文件大，且恢复速度慢
2. 数据集大的时候，比RDB启动效率低
3. 运行效率没有RDB高

#### 注意

- AOF文件比RDB更新效率高，建议优先使用AOF还原数据
- AOF比RDB更安全也更大
- RDB性能比AOF好
- 如果两种持久化方案都配置了，则会默认使用AOF机制

#### 修复工具

redis-check-aof

## Redis的过期键的删除策略

Redis设置key的过期时间

1. expire设置过期时间
2. setex设置有效时长

Redis是key-value数据库，我们可以设置Redis中缓存的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

- 惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
- 定时过期（Redis没有实现这种方案）：每一个key设置一个定时器，当过期时由定时器去删除。
- 定期过期：每隔一定的时间，会扫描一定数量的数据库（默认16个）的expires字典中一定数量的key（默认20个），并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。程序中有一个全局变量记录扫描到了哪个数据库。

（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是改建的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。）

Redis中同时使用了惰性过期和定期过期两种过期策略。

## 常见的缓存淘汰算法

插入缓存时缓存已满，若插入的缓存更重要，必须插入成功，则需要通过缓存淘汰来将原有的部分缓存删除掉

FIFO（先进先出），根据缓存存储的时间，离当前最远的数据有限被淘汰。

LRU（Least Recently Used 最近最少使用），根据最近被使用的时间，离当前最远的数据优先被淘汰。

LFU（Least Frequently Used 最不经常使用），在一段时间内，缓存数据被使用次数最少的会被淘汰。

## 分布式缓存中常用的缓存方案有哪些

客户端缓存：页面和浏览器缓存，APP缓存，H5缓存，localStorage和sessionStorage

CDN缓存：内容存储：数据的缓存，内容分发：负载均衡

nginx缓存：静态资源

服务端缓存：本地缓存、外部缓存

数据库缓存：持久层缓存（mybatis、hibernate多级缓存），MySQL查询缓存

操作系统缓存：Page Cache、Buffer Cache

## Redis分布式锁底层是如何实现的（讲的有点浅）

### setnx + setex

setnx：key不存在时设置成功，否则设置不成功

setex：为指定的key设置一个超时时间，key不存在的话会先生成key再加上超时时间

问题：

1. 设置超时时间失败，导致死锁：使用setnx设置成功后，节点宕机，导致没有运行setex命令，这样就会导致数据永远不过期，分布式锁永远拿不到，导致死锁。
2. 锁被替换掉了，del导致误删：为了防止任务执行长时间才结束导致锁变为其他进程的了，可以设置一个守护进程，锁到期时若任务没有执行完毕可以对锁进行续命操作。或者可以将value设置为自己的requestId，删除前判断锁的拥有者是否为当前节点。

### set(key, value, nx, px)

将setnx和setex变成原子操作

#### 问题

- 任务超时，锁自动释放，导致并发问题，使用redisson解决（看门狗监听，自动续期）
- 加锁和释放锁有可能不是一个线程。在value中存入uuid（线程唯一标识），删除锁时（get锁的标识+del）判断该标识（使用lua保证原子操作）
- 不可重入，使用redisson解决（实现机制类似AQS，计数）
- 异步复制可能造成锁丢失，使用redLock（红锁）解决：

1. 顺序向五个节点请求加锁
2. 根据一定的超时时间来推断是不是跳过该节点：如果某个节点超时了，则这个节点的请求加锁操作直接跳过
3. 三个节点加锁成功并且花费时间小于锁的有效期
4. 认定加锁成功

### 总结

1. 首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁
2. 然后还要利用lua脚本来保证多个redis操作的原子性
3. 同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约
4. 同时还要考虑到Redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到

## Redis和MySQL如何保证数据一致

1. 先更新MySQL，再更新Redis，但是如果更新Redis失败，可能仍然不一致
2. 先删除Redis缓存数据，再更新MySQL，再次查询的时候再将数据添加到缓存中，这种方案能解决方案一的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新MySQL，此时另外一个查询再查询，那么就会把MySQL中老数据又查到Redis中。
3. 延时双删：先删除Redis缓存数据，再更新MySQL，延迟几百毫秒后再删除Redis缓存数据，这样就算在更新MySQL时有其他线程读取了MySQL并把老数据更新到Redis中，那么也会被删除掉，从而保证数据一致。

## Redis集群方案

### 主从模式

这种模式比较简单，主库可以读写，并且会和从库进行数据同步，在这种模式下，客户端直接连接主库或者某个从库，**但是主库或者从库宕机后，客户端需要手动修改IP**，另外，这种模式也比较难以扩容，整个集群所能存储的数据受到某台机器的内存容量限制，从库仅仅只是冗余备份的角色，所以不可能支持特大的数据量。

### 主从模式+哨兵模式

这种模式在主从模式的基础上新增了哨兵节点，当主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为新增主库，另外哨兵也可以做成集群，从而可以保证单一某个哨兵节点宕机后，还要其他哨兵节点继续工作，这种模式可以比较好的保证Redis集群的高可用，但是仍然不能很好的解决Redis的容量上限问题。

sentinel，哨兵是redis集群中一个重要的组件，主要有以下功能：

- 集群监控：负责监控redis master和slave进程是否正常工作
- 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果master node挂掉了，会自动转移到slave node上
- 配置中心：如果故障转移发生了，通过client客户端新的master地址

哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群区运行，互相协同工作。

- 故障转移时，判断master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举
- 即使部分哨兵挂掉了，哨兵集群还是能正常工作的
- 哨兵通常需要3个实例，来保证自己的健壮性
- 哨兵+Redis主从的架构部署，是不保证数据零丢失的，只能保证redis集群的高可用性
- 对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境都进行充足的测试和演练。

### cluster模式

cluster模式是用的比较多的模式，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点。

#### Redis Cluster（服务端分片）

Redis Cluster是一种服务端sharding（分片）技术，3.0版本开始正式提供。采用slot（槽）的概念，一共分成16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。

互为主从，每个节点都有自己的槽，也备份其他节点的槽

##### 方案说明

- 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据，默认分配了16384个槽位
- 每份数据分片会存储在多个互为主从的多节点上
- 数据写入先写入主节点，再同步到从节点（支持配置为阻塞同步）
- 同一分片多个节点间的数据不保持强一致性
- 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点

在redis cluster架构下，每个redis都要开放两个端口号，比如一个是6379，另外一个就是+1w的端口号，比如16379

16379端口号是用来进行节点间通信的，也就是cluster  bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

##### 优点

- 无中心架构，支持动态扩容，对业务透明
- 具备Sentinel的监控和自动Failover（故障转移）能力
- 客户端不需要连接集群的所有节点，连接集群中任何一个可用节点即可
- 高性能，客户端直连redis服务，免去了proxy代理的损耗

##### 缺点

- 运维也很复杂，数据迁移需要人工干预
- 只能使用0号数据库
- 不支持批量操作（pipeline管道操作）
- 分布式逻辑和存储模块耦合（查询必须去真正存储的节点查询）

#### Redis Sharding（客户端分片）

Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法，其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。java redis客户端驱动jedis支持RedisSharding 功能，即sharded Jedis以及结合缓存池的ShardedJedisPool

##### 优点

优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强

##### 缺点

由于sharding处理放在了客户端，规模进一步扩大时给运维带来挑战

客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化。

**对于这三种模式，如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么可以选择cluster模式。**

## Redis主从复制的核心原理

通过执行slaveof命令或设置slaveof选项，让一个服务器区复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

### 全量复制

1. 主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存（页表复制）、磁盘IO的
2. 主节点通过网络将RDB文件发送给从节点，对朱从节点的带宽会带来很大的消耗
3. 从节点清空老数据，载入新RDB文件的过程是阻塞的，无法响应客户端的命令，如果从节点执行bgrewriteaof，也会带来额外的消耗

### 增量复制（部分复制）

1. 复制偏移量：执行复制的双方，主从节点分别会维护一个复制偏移量
2. 复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出（FIFO）队列，作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。

服务器运行ID（runid）：每个redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发生给从节点，从节点会将主节点的运行ID存起来、从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：

- 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制（能不能复制还需要看offset和复制积压缓冲区的情况）
- 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的redis节点并不是当前的主节点，只能进行全量复制

## 布隆过滤器原理、优缺点

### 原理

位图：int[10]，每个int类型的整数是4*8=32个bit，则int[10]一共有320个bit，每个bit非1即0，初始化时都是0

添加数据时，将数据进行hash得到hash值，对应的bit位，则将该bit位改为1，hash函数可以定义多个，则一个数据添加会将多个（hash函数个数）bit位改为1，多个hash函数的目的是减少hash碰撞的概率

查询数据：hash函数计算得到hash值，对应的bit中，如果有一个为0，则说明数据不在缓存中，如果都为1，则说明数据**有可能**在缓存中。

### 优点

- 占用内存小
- 增加和查询元素的时间复杂度为O(k)（k为hash函数的个数，一般比较小），与数据量大小无关
- 哈希函数相互之间没有关系，方便硬件并行计算
- 布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势
- 数据量很大时，布隆过滤器可以表示全集
- 使用同一组散列函数的布隆过滤器可以进行交、并、差运算

### 缺点

- 误判率，即存在假阳性（False Position），不能准确判断元素是否在集合中。hash函数需要足够好，降低hash碰撞的概率
- 不能获取元素本身
- 一般情况下不能从布隆过滤器中删除元素，只能增不能减(可以通过维护count来删除)

## 什么是缓存穿透、缓存击穿、缓存雪崩，怎样解决？

### 缓存穿透

查询缓存中不存在，数据库中也不存在的数据。即使用不存在的key发大量的请求，导致所有请求落到db上。

#### 解决方案

1. 对参数进行合法性校验
2. 将数据库中没有查到结果的数据也写入到缓存。这时候要注意，为了防止Redis被无用的key占满，这一类缓存的有效期要设置的短一点
3. 引入布隆过滤器，在访问redis之前判断数据是否存在。要注意存在一定的误判率且只能加数据不能减数据。

### 缓存击穿

缓存中没有，但是数据库中有。一般出现在**缓存数据初始化及key过期了**的情况。它的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间打到DB上，给DB造成很大的压力。

热点数据忽然失效，导致这个热点数据的查询瞬间落到db上

#### 解决方案

1. 设置这个热点缓存永不过期。这时要注意在value当中（存储的对象中）包含一个逻辑上的过期时间，另起一个线程，定期重建这些缓存
2. 加载DB的时候，要防止并发。将缓存加载到redis当中时，加一个锁，只能让一个进程去写入缓存。

### 缓存雪崩

缓存大面积过期，大量的key在一瞬间失效，导致所有请求都打到了db。

解决方案

1. 把缓存的失效时间分散开。例如在原有的统一失效时间基础上，增加一个随机值
2. 对热点数据设置永不过期

## 简述Redis事务实现

1. 事务开始

   MULTI命令的执行，标识着一个事物的开始。MULTI命令会将客户端状态的flags属性中打开REDIS_MULTI标识来完成的。

2. 命令入队

   当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列中，然后向客户端返回QUEUED回复。

   - 如果客户端发送的命令为MULTI（事务开始）、EXEC（开始执行）、WATCH（Key值的监控）、DISCARD(事务终止)中的一个，立即执行这个命令

   - 如果客户端发送的是四个命令以外的其他命令，则服务器并不立即执行这个命令

     首先检查此命令的格式是否正确（检查语法），如果不正确，服务器会在客户端状态（redisClient）的flags属性关闭REDIS_MULTI标识，并且返回错误信息给客户端。

     如果正确，将这个命令放入一个事务队列里，然后向客户端返回QUEUED回复。

   事务队列是按照FIFO的方式保存入队的命令的。

3. 事务执行

   客户端发送EXEC命令，服务器执行EXEC命令逻辑：

   - 如果客户端状态的flags属性不包含REDIS_MULTI标识，或者包含REDIS_DIRTY_CAS或者REDIS_DIRTY_EXEC标识，那么就直接取消事务的执行。
   - 否则客户端处于事务状态（flags有REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将结果全部返回给客户端。

   redis不支持事务回滚机制，但是他会检查每一个事务中的命令是否错误。

   redis事务不支持检查哪些程序员自己的逻辑错误（使用hashMap的操作命令去操作String）

   - WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set（CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就都不会执行，监控一直持续到EXEC命令。
   - MULTI命令用于开启一个事务，他总是返回OK。MULTI命令执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
   - EXEC：执行所有事务块中的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值null。
   - 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。
   - UNWATCH命令可以取消watch对所有key的监控。

