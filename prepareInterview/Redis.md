# Redis

## Redis单线程为什么这么快

Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快

1. 使用简单的数据结构
2. 基于内存
3. 使用非阻塞IO多路复用模型
   1. redis基于Reactor模式开发了网络事件处理器（单线程）、文件事件处理器file event handler。他是单线程的，所以redis才叫做单线程的模型，它采用io多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。
   2. 需要了解Epoll的实现机制。
   3. 文件事件处理器的结构包括4个部分：多个Socket、IO多路服用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。
   4. 多个Socket可能并发产生不用的事件，IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中有序、同步取出一个Socket给事件分派器，事件分派器会把Socket分给对应的事件处理器。
   5. 当Socket的事件处理完成之后，IO多路复用程序才会将队列中的下一个Socket给事件分配器，文件事件分派器会根据每个Socket当前产生的事件来选择对应的事件处理器来处理。
4. 自己实现了VM
5. 单线程，避免了不必要的上下文切换和竞争条件

## Redis的持久化机制

### RDB（Redis Database）：

将某一时刻的内存快照，以二进制的方式写入磁盘。

#### 手动触发

- ​	save命令，使Redis处于阻塞状态，直到RDB持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。
- ​	bgsave命令，fork出一个子进程进行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了。使用了操作系统的cow（copy on write）写时拷贝机制，主进程会操作一个原数据的数据副本。

#### 自动触发

- ​	save m n：在m秒内，如果有n个键发生改变，则自动触发持久化，通过bgsave执行，**如果设置多个，只要满足其一就会触发**，配置文件有默认配置（可以注释掉）。
- ​	flushall：用于清空redis所有的数据库；而flushdb命令清空当前redis所在库数据（默认是0号数据库），这两个命令都会清空RDB文件，同时也会生成dump.rdb，内容为空。
- ​	主从同步：全量同步时会自动触发bgsave命令，生成rbd发送给从节点。



#### 优点

1. 整个redis数据库中质保函一个文件dump.rdb，方便持久化
2. 容灾性好，方便备份
3. 性能最大化，fork子进程来完成写操作，让主进程继续执行命令，所以是io最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis 的高性能。
4. 相对于数据集大时，比AOF的启动效率更高。

#### 缺点

1. 数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失的风险，所以这种方式更适合数据要求不严谨的时候
2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集比较大时，可能会导致整个服务器停止服务几百毫秒，甚至到1s。并且fork出来的子进程会占用CPU。

### AOP（Append Only File）：

以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的访视记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘

1. 所有的写命令会追驾到AOF缓冲中
2. AOF缓冲区根据对应的策略向磁盘进行同步操作
3. 随着AOF文件越来越大，需要定期对AOF文件进行重写（rewrite），达到压缩的目的，例如通过三条命令往list中分别写入1、2、3，可以写为一条命令往list中写入1、2、3
4. 当Redis重启时，可以加载AOF文件进行数据恢复

#### 同步策略

- 每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失
- 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条
- 不同步：由操作系统控制，可能丢失较多数据

#### 优点

1. 数据安全
2. 通过append模式谢文杰，及是中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题。
3. AOF机制的rewrite模式，定期对AOF文件进行重写，以达到压缩的目的

#### 缺点

1. AOF文件比RDB文件大，且恢复速度慢
2. 数据集大的时候，比RDB启动效率低
3. 运行效率没有RDB高

### 注意

- AOF文件比RDB更新效率高，建议优先使用AOF还原数据
- AOF比RDB更安全也更大
- RDB性能比AOF好
- 如果两种持久化方案都配置了，则会默认使用AOF机制

## Redis的过期键的删除策略

Redis是key-value数据库，我们可以设置Redis中缓存的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

- 惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
- 定时过期（Redis没有实现这种方案）：每一个key设置一个定时器，当过期时由定时器去删除。
- 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是改建的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。）

Redis中同时使用了惰性过期和定期过期两种过期策略。

## *Redis分布式锁底层是如何实现的（讲的有点浅）

1. 首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁
2. 然后还要利用lua脚本来保证多个redis操作的原子性
3. 同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约
4. 同时还要考虑到Redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到

## Redis和MySQL如何保证数据一致

1. 先更新MySQL，再更新Redis，但是如果更新Redis失败，可能仍然不一致
2. 先删除Redis缓存数据，再更新MySQL，再次查询的时候再将数据添加到缓存中，这种方案能解决方案一的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新MySQL，此时另外一个查询再查询，那么就会把MySQL中老数据又查到Redis中。
3. 延时双删：先删除Redis缓存数据，再更新MySQL，延迟几百毫秒后再删除Redis缓存数据，这样就算在更新MySQL时有其他线程读取了MySQL并把老数据更新到Redis中，那么也会被删除掉，从而保证数据一致。

## Redis集群方案

### *主从模式

### 主从模式+哨兵模式

sentinel，哨兵是redis集群中一个重要的组件，主要有以下功能：

- 集群监控：负责监控redis master和slave进程是否正常工作
- 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果master node挂掉了，会自动转移到slave node上
- 配置中心：如果故障转移发生了，通过client客户端新的master地址

哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群区运行，互相协同工作。

- 故障转移时，判断master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举
- 及是部分哨兵挂掉了，哨兵集群还是能正常工作的
- 哨兵通常需要3个实例，来保证自己的健壮性
- 哨兵+Redis主从的架构部署，是不保证数据零丢失的，只能保证redis集群的高可用性
- 对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境都进行充足的测试和演练。

### Redis Cluster（服务端分片）

Redis Cluster是一种服务端sharding（分片）技术，3.0版本开始正式提供。采用slot（槽）的概念，一共分成16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。

互为主从，每个节点都有自己的槽，也备份其他节点的槽

#### 方案说明

- 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据，默认分配了16384个槽位
- 每份数据分片会存储在多个互为主从的多节点上
- 数据写入先写入主节点，再同步到从节点（支持配置为阻塞同步）
- 同一份片多个节点间的数据不保持强一致性
- 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点

在redis cluster架构下，每个redis都要开放两个端口号，比如一个是6379，另外一个就是+1w的端口号，比如16379

16379端口号是用来进行节点间通信的，也就是cluster  bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

#### 优点

- 无中心架构，支持动态扩容，对业务透明
- 具备Sentinel的监控和自动Failover（故障转移）能力
- 客户端不需要连接集群的所有节点，连接集群中任何一个可用节点即可
- 高性能，客户端直连redis服务，免去了proxy代理的损耗

#### 缺点

- 运维也很复杂，数据迁移需要人工干预
- 只能使用0号数据库
- 不支持批量操作（pipeline管道操作）
- 分布式逻辑和存储模块耦合（查询必须去真正存储的节点查询）

### Redis Sharding（客户端分片）

Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法，其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。java redis客户端驱动jedis支持RedisSharding 功能，即sharded Jedis以及结合缓存池的ShardedJedisPool

#### 优点

优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强

#### 缺点

由于sharding处理放在了客户端，规模进一步扩大时给运维带来挑战

客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化。

## Redis如何配置key的过期时间，它的实现原理是什么？

redis设置key的过期时间

1. expire设置过期时间
2. setex设置有效时长

实现机制





缓存雪崩：大量的key在一瞬间失效，导致所有请求都打到了db

缓存穿透：使用不存在的key发大量的请求，导致所有请求落到db上

缓存击穿：热点数据忽然失效，导致这个热点数据的查询瞬间落到db上

- Redis 有哪些类型

- - String
  - List
  - Hash
  - Set
  - ZSet
  - **HyperLogLog**
  - **Geo**
  - **Pub/Sub**
  - **Redis Module****：BloomFilter**

- Redis 内部结构

- 聊聊 Redis 使用场景

- Redis 持久化机制

- Redis 如何实现持久化

- Redis 集群方案与实现

- Redis 为什么是单线程的

- 缓存奔溃

- 缓存降级

- 使用缓存的合理性问题