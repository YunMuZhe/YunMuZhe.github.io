# 赶紧准备！

# 不要再拖了！

# 祝你早日拿Offer!

![超越保佑！](./img/chaoyuemeimei.jpg)


需要补习的知识清单
1. 计算机基础
    数据结构与算法、网络通信、多线程、操作系统
    题目-链表：
        单链表反转
        链表中环的检测
        两个有序的链表合并
        删除链表倒数第k个节点
        寻找链表的中间节点
    循环队列判空条件：head == tail，判满条件：(tail+1)%n == head
    无论是用队列实现栈还是用栈实现队列，都是要用两个数据结构来实现另一个数据结构，很像Eden区的From和To区之间的转换，将n-1个数据由一个数据结构迁移到另一个数据机构，然后更换角色
    排序算法(最好时间复杂度、最差时间复杂度、平均时间复杂度、空间复杂度)：
        O(n^2)的排序算法有：
            冒泡排序：n\n^2\n^2\1，原地、稳定
            插入排序：n\n^2\n^2\1，原地、稳定
            选择排序：n^2\n^2\n^2\1，原地、不稳定
        O(nlogn)排序：
            归并排序：nlogn\nlogn\nlogn\logn，非原地、稳定，主要在于合并函数merge()
            快速排序：nlogn\n^2\nlogn\n，原地、不稳定
                场景题：如何在O(n)的诗句复杂度内查找一个无序数组中的第K大元素？
                    答：利用快速排序的分区方法，选择数组A[0, n-1]中最后一个元素作为pivot，对数组A进行原地分区，这样就分成了三部分：A[0, p-1], A[p], A[p+1, n-1]
                    如果K = p+1，那么A[p]就是第K大元素，否则对两边的分区进一步分区。
                    时间复杂度分析：第一次分区需要遍历n个元素，第二次为n/2, 第三次为n/4，以此类推，直到变成1，总遍历元素个数为n + n/2 + n/4 + n/8 + ... + 1 = 2n-1
        O(n)排序：
            桶排序：时间复杂度为O(n)，但是对数据要求严格，1.待排序数据容易划分为m个桶，并且桶与桶之间有着天然的大小关系。此算法适合用于外部排序。非原地，稳定
            计数排序：时间复杂度为O(n)，是桶排序的一种特殊情况，第i个桶内装的原数组中小于等于i的元素的个数。非原地，稳定
            基数排序：时间复杂度为O(n)，需要数据可以分割出独立的位，并且位与位之间要有递进关系:后面的排序能用到前面排序的结果。非原地，稳定
        题目-二分查找变体问题（P86）：
            1. 查找第一个值等于给定值的元素
            2. 查找最后一个值等于给定值的元素
            3. 查找第一个值大于或等于给定值的元素
            4. 查找最后一个值小于或等于给定值的元素
            5. 如何快速定位IP地址对应的归属地
    哈希：
        1. 哈希思想：key-value，数组其实就是一种哈希表，key为index，value为具体元素
        2. 哈希函数：hash(key)，结果需要为非负值，如果key1 == key2 => hash(key1) == hash(key2); 如果key1 != key2 => hash(key1) != hash(key2)。最后一个要求，找到不会发生哈希膨胀的哈希函数是几乎不可能的
        3. 哈希冲突：
            开放寻址法：线性探测法、二次探测法、双重哈希法
            链表法：此处有个装载因子的概念：哈希表中元素个数/哈希表的长度（“槽”的个数），其实就是所有链表的平均长度
        4. 如何打造一个工业级的哈希表
            需要满足的条件：
                1. 快速的查询、插入、删除操作
                2. 内存占用合理，不浪费过多的内存空间
                3. 性能稳定，在极端情况下性能也不会退化到无法接受的程度
            设计要点：
                1. 设计哈希函数：像数据分析法、直接寻址法、平方取中法、折叠法和随机数法
                2. 解决装载因子过大的问题：动态扩容
                3. 避免低效的扩容：将扩容时的复制操作均摊到后续的插入操作中
                4. 选择合适的冲突解决方法：
                    开放寻址法适合用于数据量比较小，装载因子较小的情况，ThreadLocalMap使用的即是此种方法
                    链表法的内存利用率比开放寻址法更高（链表可以用到时再创建），极端的哈希冲突可以使用更高级的数据结构来避免退化严重，如红黑树。
        5. 题目-哈希表优化场景问题（P101）：使用哈希表优化LUR缓存淘汰算法
        6. linkedHashMap：双向有序链表+哈希表
2. Java基础
    Java集合，IO、NIO，多线程，JVM，线上监控
3. 数据库
    MySQL基本语法使用及底层原理
4. 缓存
    Redis
5. 中间件
    rabbitMq、RocketMq、Doubbo、kafka
6. 服务器运维
    反向代理服务器nginx、服务监控nacos
7. 项目经验
    Spring原理、源码，SpringBoot、SpringCloud实操经验
8. 场景题
    大数据量、高并发